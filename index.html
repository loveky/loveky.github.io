<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8" />

  
  <title>loveky的博客</title>

  
  
  <link href="//cdn.jsdelivr.net" rel="dns-prefetch">
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  <link href="//at.alicdn.com" rel="dns-prefetch">
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  <link href="///disqus.com" rel="dns-prefetch">
  <link href="//c.disquscdn.com" rel="dns-prefetch">
  
  
  

  

  
  <meta name="author" content="loveky">
  

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@loveky_">
  <meta name="twitter:title" content="loveky的博客">
  
  <meta name="twitter:image" content="/images/avatar.png">

  
  <meta property="og:type" content="website">
  <meta property="og:title" content="loveky的博客">
  
  <meta property="og:url" content="https://loveky.github.io/">
  <meta property="og:image" content="/images/avatar.png">




<meta name="generator" content="Hugo 0.55.6">


<link rel="canonical" href="https://loveky.github.io/">
<link rel="alternate" type="application/rss+xml" href="https://loveky.github.io/index.xml" title="loveky">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">







<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="loveky">
<meta name="msapplication-tooltip" content="loveky">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
<link rel="icon" href="https://loveky.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://loveky.github.io/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://loveky.github.io/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="https://loveky.github.io/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="https://loveky.github.io/icons/icon-152x152.png">
<link rel="manifest" href="https://loveky.github.io/manifest.json">


<link rel="preload" href="https://loveky.github.io/styles/main.min.css" as="style">
<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="https://loveky.github.io/images/avatar.png" as="image">
<link rel="preload" href="https://loveky.github.io/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="https://loveky.github.io/styles/main.min.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114966753-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-114966753-1');
</script>







  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


</head>
  <body>
    
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
    </div>
    
     <header class="site-header">
  <img class="avatar" src="https://loveky.github.io/images/avatar.png" alt="Avatar">
  
  <h1 class="title">loveky</h1>
  
  <p class="subtitle">记录生活点滴</p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
           is-active
          
          ">
          <a href="https://loveky.github.io/">首页</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/tags/">标签</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/archive/">归档</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/links/">链接</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/about/">关于我</a>
        </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item">
          <a href="mailto:eWx6Y3lseEBnbWFpbC5jb20=" title="Email" aria-label="Email">
            <span class="icon icon-email" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//github.com/loveky" title="GitHub" aria-label="GitHub">
            <span class="icon icon-github" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//twitter.com/loveky_" title="Twitter" aria-label="Twitter">
            <span class="icon icon-twitter" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//stackoverflow.com/users/1513552" title="stackOverflow"  aria-label="stackOverflow">
            <span class="icon icon-stackoverflow" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//www.zhihu.com/people/loveky" title="Zhihu" aria-label="Zhihu">
            <span class="icon icon-zhihu" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//www.douban.com/people/54047566" title="Douban" aria-label="Douban">
            <span class="icon icon-douban" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a rel="alternate" type="application/rss+xml" href="https://loveky.github.io/index.xml" title="RSS" aria-label="RSS">
            <span class="icon icon-rss" aria-hidden="true"></span>
          </a>
        </li></ul>
  </nav>
</header>

<section class="main post-list">
  <header class="list-header offscreen">
    <h2 class="list-label">All Posts</h2>
  </header>
  
  
   <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/08/27/node-child_process-fork-spawn-exec-execfile/" class="post-link">child_process 模块中的 spawn fork exec 与 execFile</a></h3>
    <p class="post-meta">@loveky · Aug 27, 2019</p>
  </header>
  
    <img class="post-cover" src="https://blog-1300104298.cos.ap-beijing.myqcloud.com/Snipaste_2019-08-27_22-08-24.png" alt="child_process 模块中的 spawn fork exec 与 execFile" lazyload="on">
  
  <p class="post-summary">具体用法参考官方文档即可，已经写的很清楚。本文仅做一些简单对比。
简单对比    方法 spawn fork exec execFile     是否通过 shell 执行子命令 否(*) 否 是 否(*)   读取程序输出 利用子进程的 stdout / stderr 利用子进程的 stdout / stderr 在 callback 中一次返回 在 callback 中一次返回   父子进程通信 process.send() 与 process.on(&#34;message&#34;) (仅当子进程为 Node 脚本时可用) process.send() 与 process.on(&#34;message&#34;) 不支持 不支持   备注  仅限执行 Node 脚本      说明  fork、exec、execFile 都是 spawn 的一种特殊情况，内部都是调用了 spawn 方法。 spwan 和 execFile 默认是创建子进程直接执行指定命令，但是可以通过 option 中的 shell 字段来明确要求在一个 shell 中执行命令。 由于 exec 和 execFile 会把子进程的 stdout 和 stderr 缓存起来一次性返回给调用方，在子进程退出之前，这些缓存数据会在内存中不断累积。为了防止内存占用过多导致的问题，这两个方法的参数对象中接受一个 maxBuffer 字段，表示缓存数据的上限大小，超过该大小会导致子进程被 kill() 且缓存数据会被截断。该参数的默认值是 1024 * 1024。 以上几个方法的源码都在 lib/child_process.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/08/27/node-child_process-fork-spawn-exec-execfile/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/06/25/regexp-lookahead-assertion/" class="post-link">正则表达式中的 lookahead 断言与 lookbehind 断言</a></h3>
    <p class="post-meta">@loveky · Jun 25, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img13.360buyimg.com/uba/s300x300_jfs/t1/41595/38/7447/103723/5d118e9cEe8022b1a/4e79718fdac26cc2.png" alt="正则表达式中的 lookahead 断言与 lookbehind 断言" lazyload="on">
  
  <p class="post-summary">一个正则表达式引发的空白 最近在开发内部的一个前端异常监控系统，在 Web 端会展示异常上报的来源 IP 以及所在地，大概是这个样子的：
由于页面空间有限且几乎所有的异常都来自国内，因此做了一个简单的优化，将所在地字符串开头处的“中国”二字移除掉，写个很简单的正则表达式即可：
result.replace(/^中国/, &#34;&#34;)  改完以后，效果还不错：
直到有一天小伙伴反馈问题，有的 IP 的地理位置展示了空白，像这样：
简单调查了一下发现该 IP 的查询结果只有“中国”二字，于是经过前面的处理逻辑后就只剩下空字符串了。
解决方案 最直接的想法就是增加一个 if / else 判断，如果查询结果是“中国”二字，则跳过正则处理。
虽然直接，但是感觉不够简洁。能否在原来的正则表达式上优化一把来实现我们要的效果呢？使用今天要说的 lookahead 断言就可以。
lookahead 断言 在说 lookahead 断言前我们先看看另一个写法：
result.replace(/^中国./, &#34;&#34;)  这种写法在“中国”二字后多匹配了一个字符，这样写可以避免处理仅有“中国”二字的情况，但带来一个新的问题：在多个字的情况下，多删掉了一个字符。
我们想要的只是一个 0 长度的断言而不是真正匹配什么内容，就像 \b，^，$ 那样，只表示某个条件是否达成，但并不匹配字符串中的内容。
这就是 lookahead 的意义，我们只需将正则改写成：
result.replace(/^中国(?=.)/, &#34;&#34;)  就可以表示只匹配之后还有其它字符的“中国”二字的含义。
lookahead 断言的写法就是 (?=(regex)) 其中(regex) 就是你想断言的条件。
只需要将 = 改成 ! 你就得到了一个否定形式的 lookahead 断言，例如 /^中国(?!.)/ 就表示之后没有任何其它字符的“中国”二字。
lookbehind 断言 与 lookahead 对应的，还有 lookbehind 断言以及它的否定形式：
/(?&lt;=(regex))/ /(?</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/06/25/regexp-lookahead-assertion/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/05/02/meet-deno/" class="post-link">初识 Deno</a></h3>
    <p class="post-meta">@loveky · May 2, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img30.360buyimg.com/uba/jfs/t1/33681/25/10580/438939/5ccedcd9Eefb0efcf/60eb84fc6c066d49.gif" alt="初识 Deno" lazyload="on">
  
  <p class="post-summary">几天前的 JavaScript Weekly 里推送了一条名为 “A Look at Deno: A New JavaScript Runtime” 的视频，视频的内容是 Deno 的作者(同时也是 Node.js 项目的最初发起人与维护者) Ryan Dahl 在今年 4 月初的 JS Fest 大会上做的关于 Deno 的演讲。
 Deno, a new way to JavaScript  看完视频感觉这个项目挺有趣，于是花了一点时间做了一些了解，记录如下。
</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/05/02/meet-deno/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/02/14/typescript-generic/" class="post-link">TypeScript 中的泛型(Generic)</a></h3>
    <p class="post-meta">@loveky · Feb 14, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img12.360buyimg.com/uba/s300x300_jfs/t1/30646/20/1952/28135/5c63d9dbEc21e77b4/0f96a5ed30759c29.png" alt="TypeScript 中的泛型(Generic)" lazyload="on">
  
  <p class="post-summary">在函数中使用泛型 这里 T 可以代表任意类型。
function identity&lt;T&gt;(arg: T): T { return arg; } 使用时可以明确指定类型：
let output = identity&lt;string&gt;(&#34;myString&#34;);  不过更多时候是交给 TypeScript 进行类型推断：
let output = identity(&#34;myString&#34;);  在接口中使用泛型 interface GenericIdentityFn { &lt;T&gt;(arg: T): T; } function identity&lt;T&gt;(arg: T): T { return arg; } let myIdentity: GenericIdentityFn = identity; 我们还可以把泛型参数提升到整个接口的层面，像下面这样：
interface GenericIdentityFn&lt;T&gt; { (arg: T): T; } 然后在我们使用这个接口的时候，必须明确指定这个泛型参数的类型：
function identity&lt;T&gt;(arg: T): T { return arg; } let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 我们得到的 myIdentity 方法只能接受数字作为参数。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/02/14/typescript-generic/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/02/13/typescript-function-types-and-indexed-types/" class="post-link">TypeScript 中的函数类型与索引类型</a></h3>
    <p class="post-meta">@loveky · Feb 13, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img12.360buyimg.com/uba/s300x300_jfs/t1/30646/20/1952/28135/5c63d9dbEc21e77b4/0f96a5ed30759c29.png" alt="TypeScript 中的函数类型与索引类型" lazyload="on">
  
  <p class="post-summary">函数类型 利用 interface 声明函数类型，只需要把接口定义中的属性写成函数签名即可。
像这样：
interface SearchFunc { (source: string, subString: string): boolean; } 如果我们的函数本身还有一些属性，例如 Node.js 中的 require() 方法，我们既可以 require(&#34;package&#34;) 又可以 require.resolve(&#34;package&#34;)。这是需要首先为该方法定义一个接口，然后再通过 extends 它来添加属性。
interface NodeRequireFunction { (id: string): any; } interface NodeRequire extends NodeRequireFunction { resolve: RequireResolve; cache: any; extensions: NodeExtensions; main: NodeModule | undefined; } 索引类型 有时我们想让我们对象支持向数组那样按照数字下标来存取数据，有时我们会想创建一个”字典”对象来存取任意的 “key/value” 对应关系。这两种情况就需要声明索引类型。区别在于索引本身的类型是数字还是字符串。
interface StringArray { [index: number]: string; } interface NameAddressMap { [index: string]: string; } 我们可以把一个对象声明成既支持字符串索引有支持数字索引：
interface ItsOK { [index: string]: string; [index: number]: string; } 如果我们的对象要同时支持两种索引类型，那么必须保证字符串索引对应值的类型是数字索引对应值的类型的超集。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/02/13/typescript-function-types-and-indexed-types/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/02/12/nodejs-module-system/" class="post-link">Node.js 的模块系统</a></h3>
    <p class="post-meta">@loveky · Feb 12, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img20.360buyimg.com/uba/s300x300_jfs/t1/28747/1/6830/6538/5c6276c0E58a5b593/13cf35af9b707192.png" alt="Node.js 的模块系统" lazyload="on">
  
  <p class="post-summary">两个核心模块 require 和 module。
require 模块对应全局的 require 方法。module 模块对应每一个模块全局空间中的 module 属性。
Node.js 加载一个模块主要经历以下几个步骤：
 Resolving -&gt; Loading -&gt; Wrapping -&gt; Evaluating -&gt; Caching
 Resolving Node.js 中的模块和文件系统中的文件是一一对应的（这一点很重要）。加载模块的过程其实就是执行文件系统中的脚本并将结果载入内存的过程。
每一个模块都有一个 id 属性，该属性的值就是这个模块对应文件的绝对路径（在 REPL 里为 ““）。
Resolving 阶段的工作就是把我们 require 的字符串解析成一个文件系统中的绝对路径。根据我们 require 包的类型，这里又分为三种情况：
 核心模块。也即 Node.js 内置的模块，例如 “fs”、”path”、”http” 等，这类模块无需安装即可直接使用。 相对路径/绝对路径。Node.js 直接将相对路径转换成对应的绝对路径。 第三方依赖。如果不是前两种情况，那么 Node.js 会依次查找 module.paths 列表中的目录是否存在。 我们来看看 module.paths 中都有哪些目录： 可以看到主要是从当前目录逐级向上查找 node_modules 目录。这也就是为什么我们的依赖会被安装在 node_modules 目录下的原因。 为了向前兼容，Node.js 还会检查一些已经被废弃的目录，不推荐使用它们。
在找到这个列表中某个存在的目录之后，Node.js 会在该目录下继续查找，假设我们执行的是 require(&#34;moduleA&#34;)，那么又可以分为以下三种情况：
 存在一个 moduleA.js 文件，那么该文件就是最终我们要加载的文件。 存在一个 moduleA 子目录，且该目录下存在一个名为 index.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/02/12/nodejs-module-system/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/02/11/yarn-pnp/" class="post-link">Yarn 的 Plug&#39;n&#39;Play 特性</a></h3>
    <p class="post-meta">@loveky · Feb 11, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img20.360buyimg.com/uba/s300x300_jfs/t1/8346/34/14379/15918/5c616cecE985b19c2/350ab0c1cb269d3a.jpg" alt="Yarn 的 Plug&#39;n&#39;Play 特性" lazyload="on">
  
  <p class="post-summary">前言 Yarn 团队在春节前公布了 Yarn 2.0 的规划。其中提到了一个之前没听说过的名词 “PnP”。发现 Yarn 的这个功能早在 18 年 9 月份就被提出并实现了。于是花了一些时间了解了一下它的工作原理以及解决的问题并整理除了本篇文章。
现状与痛点 Yarn 团队开发 PnP 特性最直接的原因就是现有的依赖管理方式效率太低。引用依赖时慢，安装依赖时也慢。
先说说 Node 在处理依赖引用时的逻辑，这个流程会有如下两种情况：
 如果我们传给 require() 调用的参数是一个核心模块（例如 “fs”、”path”等）或者是一个本地相对路径（例如 ./module-a.js 或 /my-li/module-b.js），那么 Node 会直接使用对应的文件。 如果不是前面描述的情况，那么 Node 会开始寻找一个名为 node_modules 的目录：  首先 Node 会在当前目录寻找 node_modules，如果没有则到父目录查找，以此类推直到系统根目录。 找到 node_modules 目录之后，再在该目录中寻找名为 moduleName.js 的文件或是名为 moduleName 的子目录。   此处旨在说明问题，对 Node 内部模块解析逻辑做了简化描述
可见 Node 在解析依赖时需要进行大量的文件 I/O 操作，效率并不高。
再来看看安装依赖时发生了什么，现阶段 yarn install 操作会执行以下 4 个步骤：
 将依赖包的版本区间解析为某个具体的版本号 下载对应版本依赖的 tar 包到本地离线镜像 将依赖从离线镜像解压到本地缓存 将依赖从缓存拷贝到当前目录的 node_modules 目录  其中第 4 步同样涉及大量的文件 I/O，导致安装依赖时效率不高（尤其是在 CI 环境，每次都需要安装全部依赖）。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/02/11/yarn-pnp/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2018/07/18/how-flutter-inheritedwidget-works/" class="post-link">从 Flutter 源码看 InheritedWidget 内部实现原理</a></h3>
    <p class="post-meta">@loveky · Jul 18, 2018</p>
  </header>
  
    <img class="post-cover" src="https://img11.360buyimg.com/uba/s300x300_jfs/t23086/34/1085755315/92891/9249e03d/5b4f1c76N2108c1ca.jpg" alt="从 Flutter 源码看 InheritedWidget 内部实现原理" lazyload="on">
  
  <p class="post-summary">这两天学习了一下 Flutter 中的 InheritedWidget 的使用方法，顺便查看一下相关源码了解了其底层实现机制。特地记录一下。
Prerequirements 由于本文主要是从源码的角度分析 InheritedWidget 的工作原理，所以对阅读本文的小伙伴的 Flutter 知识有一定的要求。主要有以下几点，如果其中某部分你还不太清楚，请先阅读相关链接：
 了解 Flutter 的基本用法。 了解 Flutter 中的 Widget 和 Element 的基本概念。 推荐阅读：Flutter, what are Widgets, RenderObjects and Elements? 对 Flutter 中 Element 的生命周期有基本了解。推荐阅读：Element class  下面开始正文。
InheritedWidget 的使用方法 先看一个 InheritedWidget 最简单的使用示例：
import &#39;package:flutter/material.dart&#39;; void main() =&gt; runApp(new MyApp()); class MyWelcomeInfo extends InheritedWidget { MyWelcomeInfo({Key key, this.welcomeInfo, Widget child}) : super(key: key, child: child); final String welcomeInfo; @override bool updateShouldNotify(InheritedWidget oldWidget) { return oldWidget.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2018/07/18/how-flutter-inheritedwidget-works/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2018/07/13/flutter-listview-child-visibility-monitor/" class="post-link">Flutter 中 ListView 组件的子元素曝光统计</a></h3>
    <p class="post-meta">@loveky · Jul 13, 2018</p>
  </header>
  
    <img class="post-cover" src="https://img11.360buyimg.com/uba/s300x300_jfs/t20749/152/2116621965/135404/e6908175/5b47fd61Ne37248ec.jpg" alt="Flutter 中 ListView 组件的子元素曝光统计" lazyload="on">
  
  <p class="post-summary">在使用 Flutter 开发应用的过程中我们经常遇到需要展示一组连续元素的情景。这时我们通常会选择使用 ListView 组件。在电商场景中，被展示的元素通常是一组商品、一组店铺又或是一组优惠券信息。把这些信息正确的展示出来仅仅是第一步，通常业务同学为了统计用户的浏览习惯、活动的展示效果还会让我们上报列表元素的曝光信息。
什么是曝光信息？ 什么是曝光是信息呢？简单来说就是用户实际看到了一个列表中的哪些元素？实际展示给用户的这部分元素用户浏览了多少次？
让我们通过一个简单示例应用来说明：
import &#39;package:flutter/material.dart&#39;; class Card extends StatelessWidget { final String text; Card({ @required this.text, }); @override Widget build(BuildContext context) { return Container( margin: EdgeInsets.only(bottom: 10.0), color: Colors.greenAccent, height: 300.0, child: Center( child: Text( text, style: TextStyle(fontSize: 40.0), ), ), ); } } class HelloFlutter extends StatelessWidget { final items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; @override Widget build(BuildContext context) { return ListView.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2018/07/13/flutter-listview-child-visibility-monitor/">阅读全文 →</a>
  </footer>
</article>
  <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2018/07/05/config-lantern-as-shell-proxy/" class="post-link">利用蓝灯为命令行配置HTTP代理</a></h3>
    <p class="post-meta">@loveky · Jul 5, 2018</p>
  </header>
  
    <img class="post-cover" src="https://img11.360buyimg.com/uba/jfs/t22204/310/1882466733/2312/45f34ee8/5b3d8ad9N988340c6.png" alt="利用蓝灯为命令行配置HTTP代理" lazyload="on">
  
  <p class="post-summary">蓝灯是个好工具。可以帮忙我们访问一些由于众所周知的原因在国内无法正常访问的网站(比如 Google、Stack Overflow、Medium 等等)。
每次启动蓝灯，它会自动修改操作系统的网络代理指向它自己。不需要我们手动配置，很是方便。
需要网络代理的地方其实不止是浏览器，很多命令行工具也会访问网络。比如，我们通过 homebrew 安装 dart 的时候，brew 命令会从 Google 的服务器上下载安装文件。然后你就会看到网络连接错误的提示信息。
要解决这类问题，只需要为 Shell 设置两个环境变量 HTTP_PROXY 和 HTTPS_PROXY 即可。我们直接利用蓝灯在本地启动好的代理端口。
我们首先找到蓝灯在本地启动的具体端口号。打开蓝灯，依次选择 Settings -&gt; ADVANCED SETTINGS 即可看到蓝灯在本地选择的端口号。
然后去 Shell 里执行以下两个命令设置环境变量：
export HTTP_PROXY=http://127.0.0.1:51350 export HTTPS_PROXY=http://127.0.0.1:51350 就完成配置了。
最后为了避免每次都要敲这么长的命令，我们写一个 Shell 函数：
# http proxy util hp() { if [ &#34;$1&#34; = &#34;enable&#34; ] then PORT=&#34;51350&#34; if [ -n &#34;$2&#34; ] then PORT=&#34;$2&#34; fi export HTTP_PROXY=http://127.0.0.1:$PORT export HTTPS_PROXY=http://127.0.0.1:$PORT else export HTTP_PROXY=&#34;&#34; export HTTPS_PROXY=&#34;&#34; fi } 把这都函数代码放到 Shell 启动脚本里。然后需要开启代理的时候执行 hp enable 即可，或是指定代理端口号 hp enable 33333。关闭代理执行 hp 即可。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2018/07/05/config-lantern-as-shell-proxy/">阅读全文 →</a>
  </footer>
</article>
 
   
  <footer class="list-footer">
    <nav class="pagination">
      <h3 class="offscreen">Pagination</h3>
       
      <a class="pagination-next" href="https://loveky.github.io/page/2/"
        >Older Posts →</a
      >
      
    </nav>
  </footer>
  
</section>

<footer class="site-footer">
  <p>© 2017-2020 loveky</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>








<script src="https://loveky.github.io/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>






 
  </body>
</html>
