<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8" />

  
  <title>
  Posts
   | loveky的博客
</title>

  
  
  <link href="//cdn.jsdelivr.net" rel="dns-prefetch">
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  <link href="//at.alicdn.com" rel="dns-prefetch">
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  <link href="///disqus.com" rel="dns-prefetch">
  <link href="//c.disquscdn.com" rel="dns-prefetch">
  
  
  

  

  
  <meta name="author" content="loveky">
  

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@loveky_">
  <meta name="twitter:title" content="loveky的博客">
  
  <meta name="twitter:image" content="/images/avatar.jpg">

  
  <meta property="og:type" content="website">
  <meta property="og:title" content="loveky的博客">
  
  <meta property="og:url" content="https://loveky.github.io/post/">
  <meta property="og:image" content="/images/avatar.jpg">




<meta name="generator" content="Hugo 0.54.0">


<link rel="canonical" href="https://loveky.github.io/post/">
<link rel="alternate" type="application/rss+xml" href="https://loveky.github.io/post/index.xml" title="loveky">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">







<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="loveky">
<meta name="msapplication-tooltip" content="loveky">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
<link rel="icon" href="https://loveky.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://loveky.github.io/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://loveky.github.io/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="https://loveky.github.io/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="https://loveky.github.io/icons/icon-152x152.png">
<link rel="manifest" href="https://loveky.github.io/manifest.json">


<link rel="preload" href="https://loveky.github.io/styles/main.min.css" as="style">
<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="https://loveky.github.io/images/avatar.jpg" as="image">
<link rel="preload" href="https://loveky.github.io/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="https://loveky.github.io/styles/main.min.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114966753-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-114966753-1');
</script>







  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


</head>
  <body>
    
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="https://loveky.github.io/images/avatar.jpg" alt="Avatar">
  
  <h2 class="title">loveky</h2>
  
  <p class="subtitle">记录生活点滴</p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
          
          
           is-active">
          <a href="https://loveky.github.io/">首页</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/tags/">标签</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/archive/">归档</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/links/">链接</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/about/">关于我</a>
        </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item">
          <a href="mailto:eWx6Y3lseEBnbWFpbC5jb20=" title="Email" aria-label="Email">
            <span class="icon icon-email" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//github.com/loveky" title="GitHub" aria-label="GitHub">
            <span class="icon icon-github" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//twitter.com/loveky_" title="Twitter" aria-label="Twitter">
            <span class="icon icon-twitter" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//stackoverflow.com/users/1513552" title="stackOverflow"  aria-label="stackOverflow">
            <span class="icon icon-stackoverflow" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//www.zhihu.com/people/loveky" title="Zhihu" aria-label="Zhihu">
            <span class="icon icon-zhihu" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//www.douban.com/people/54047566" title="Douban" aria-label="Douban">
            <span class="icon icon-douban" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a rel="alternate" type="application/rss+xml" href="https://loveky.github.io/index.xml" title="RSS" aria-label="RSS">
            <span class="icon icon-rss" aria-hidden="true"></span>
          </a>
        </li></ul>
  </nav>
</header>

  <section class="main post-list">
    <header class="list-header offscreen">
      <h2 class="list-label">Posts List</h2>
    </header>
    
    
      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2016/08/04/promise-try/" class="post-link">[译]什么是Promise.try</a></h3>
    <p class="post-meta">@loveky · Aug 4, 2016</p>
  </header>
  
  <p class="post-summary">原文地址 http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/
在#Node.js#频道里经常困扰大家的一个话题是Bluebird提供的Promise.try方法。大家并不清楚该方法的功能也不知道为何要使用它。同时，几乎所有的关于Promsie的指南中针对该方法错误的演示使得这种情况没有任何改善。
在本文中，我会尝试解释究竟什么是Promise.try以及为何你应该使用它。我假设你已经对Promise有所了解并且知道.then在Promise中的作用。
即使你在使用一个不同的Promsie实现(例如ES6 Promise)，本文还是可以帮到你。文章末尾我会解释如何在非Bluebird环境中实现相同的功能。
究竟什么是Promise.try呢？ 简单来说，除了不需要跟在一个前置Promise之后以外，Promise.try很像.then。这么说还是有一些含糊不清，所以让我们先看一个示例。
以下是一段典型的Promise使用场景：
function getUsername(userId) { return database.users.get({id: userId}) .then(function(user) { return user.name; }); }  到目前为止，一切顺利。我们假设database.users.get会返回一个Promise，并且该Promise最终会返回一个带有name属性的对象。
以下是同样的代码，但是引入了Promise.try：
var Promise = require(&#34;bluebird&#34;); function getUsername(userId) { return Promise.try(function() { return database.users.get({id: userID}); }).then(function(user) { return user.name; }); }  可以看到，我们的调用链以Promise.try而不是database.users.get开始。像使用.then一样，我们执行Promise.try方法并传递给它一个直接返回database.users.get调用的函数。
这样做有什么意义呢？ 以上的代码看起来似乎是多余的。但实际上它有以下几个优点：
 更好的错误处理 同步代码中的异常不论出现在何处都会以rejection的形式向Promise链后端传递。 更好的兼容性 你可以始终使用你自己喜欢的Promise实现，而不用担心第三方代码在使用哪个。 更好的代码阅读体验 所有的代码在水平方向上将处于同一个缩进层级，这将使你阅读代码变得更容易。  接下来我会逐一介绍这些优点：
1. 更好的错误处理 Promise的一个被大力宣扬的优点就是用户可以用同一种方式同时处理同步异常和异步异常 —— 同步异常会被捕获并且会作为一个rejected Promise向后传递。但事实真的是这样吗？让我们看看以下这个上文示例的小变种：
function getUsername(userId) { return database.users.get({id: userId}) .then(function(user) { return uesr.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2016/08/04/promise-try/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2016/07/12/find-time-to-be-a-better-developer/" class="post-link">[译] 寻找时间成为一名更优秀的程序员</a></h3>
    <p class="post-meta">@loveky · Jul 12, 2016</p>
  </header>
  
  <p class="post-summary">原文链接 https://medium.freecodecamp.com/finding-time-to-become-a-better-developer-eebc154881b2#.t1uuonhtf
没有时间做任何事。这就是你感受，不是吗？没有时间学习你觉得你需要学会以跟上潮流的知识。没有时间回过头去重构那些丑陋的代码。它至少能工作，何况截止日期马上就要到了。没有时间编写单元测试。没有时间为今后要维护你代码的伙计编写文档或注释。没有时间思考。没有时间呼吸。没时间！
好吧…如果你能花时间阅读本文，我保证你自己会为那些重要的事找到更多时间。
我曾经以为成为一名伟大程序员的唯一途径就拼命工作。我的健康，友谊，家庭都因此受到影响。理解以下5个关于时间管理的真相拯救了我。
1. 你不需要为了赶潮流而学习每一个新事物 你不需要 毫无疑问一个优秀的程序员应该保持不断的学习，但是你把学习的焦点放在哪儿能在很大程度上影响你需要花费的时间。
 “老的事物已经死去，(终归老去的)新事物万岁！”
 首先，不要被出现在那些每37秒就宣布一个新标准的博客上的头条所愚弄。这些新技术，新框架，新特性中的大多数永远都不会被认可与采纳，因此你根本不需要了解它们。那些真正能够脱颖而出的也会经历比博客圈和发明厂商宣传的长的多的时间才会被采用。公司投资于他们的技术栈 —— 和那些小创业公司不一样，他们不可能说变就变。所以，放松一下，你的职业生涯很安全。
把你的学习聚焦在三方面，以下面列出的顺序为优先级： 1. 基础 —— 当你有了非常扎实的基础知识之后，学习新技能会变得非常容易。举个例子，如果你对JavaScript有着深入的了解，你就可以飞速的掌握任何新的JavaScript框架。如果你深入学习了面向对象编程，你也能快速掌握任何新的面向对象语言。深入学习基础知识会极大的提高你的学习效率。始终把提高对基础知识的掌握放在第一位。 2. 你最常使用的技术栈的最新版本/特性 —— 存在一套你每天都会使用的技术栈。这些是可以帮你养活你及你家人的工具。当这些工具的新版本发布时，投入时间学习是很值得的。 3. 由市场领导者主导的流行技术 —— 如果一个颇具规模的公司，比如Google，Facebook或是Microsoft提出某项新技术并已经开始小有名气，这也值得你的关注。市面上曾经有许多JavaScript框架争夺人们的注意力，然后Angular和React出现了并将那些框架彻底消灭。我不是说今后不会有搅局者出现成为下一个焦点，但实际情况往往是杂牌技术只不过是一些噪音。
学习时间应该是你日程安排的一部分。每天抽出一点时间来学习。这不需要很长的时间，即使是每天花25分钟阅读和练习也可以快速积累。
2. 编写优秀的代码比编写糟糕的代码需要更少的时间，但感觉上并不是这样 时间是一个扁圆 你很可能喜欢开发完几个新功能后当你试着运行并且发现似乎可以正常工作时那一刻的感受。但那只是你时间投入的开始。在一个功能上投入的时间包括了后期调试的时间，重构花费的时间以及解决由于开发时的不良设计导致的其它问题的时间。当你开始以这种方式认识你的时间投入时，你会发现，从长远来看，更少的错误和更好的设计是值得投资的。
你可以做两件事来减少代码中的错误并实现更好的设计。 1. 使用测试驱动开发 首先编写测试，然后编写代码以使测试通过。这不仅会减少bug还会导致更好的设计，因为当你按照可测试的方式组织代码时，你最终会得到更小，更简单的，依赖更少的函数。 2. 使用迭代的设计方式 在你的代码能真正工作之前，不要花时间试图让你的代码变完美。你永远不可能在脑子里把它设计的完全正确。你必须敲击键盘来生成实现预期功能的代码。问题是程序员尝尝犯两个常见的错误：要么时花了太多时间思考而没有足够的时间动手，要么就是不去优化他们最初的方案。遵循最初由Kent Beck提出的口头禅：“make it work, make it right, make it fast” —— 按照话中的顺序。
3. 7x24的工作不会让你成为英雄，管理预期才会 下班到家，开始工作! 这一条几乎杀了我。我曾经同意并承诺过我老板或客户提出的任何疯狂的时间表。我害怕说“不”。我害怕让任何人失望。为了交付我可以做任何事。我曾经睡在办公桌下，有过多次长达40&#43;小时的马拉松式的编程经历。
起初我是一颗耀眼的明星。别人对我大加赞赏，我感觉自己像是个英雄。但是我设置了一个不可能实现的预期。不可能长久的像那样工作。最终我开始疲惫不堪，生病并错过截止日期。我开始得到不可靠的名声。这是个坏消息。
最后我终于明白真正的英雄是那些持续可靠的人。他们说到做到。要成为那样的英雄的唯一途径就是管理预期。
你需要控制时间表以便总是可以按时交付高质量的工作。起初这会非常困难。这意味着必须说“不”并把需求打回。
在最开始，你的老板和客户不会被你的拒绝刺激到。但一旦你证明自己是值得信赖的，一切都将开始改变。
随着时间的推移，其它程序员会迟到，交付马虎的工作或是筋疲力竭变得不可靠。这时你就会成为团队中真正的英雄。事实上，学会这一点让我成为我的领域里最受欢迎的咨询顾问。由于狠抓预期管理，我在质量和时效性方面建立了良好的声誉。
4. 不是所有花在“改善”代码上的时间都会得到相同的回报 花费时间是一种投资。和所有投资一样，投资回报率是一个合理的期望。你的所得至少应该和投入一样多，希望是越多越好。
我们已经谈论过“make it work, make it right, make it fast”。这个是不错的口头禅但这里有一个陷阱：“right”并不意味着完美，“fast”也不是说越快越好。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2016/07/12/find-time-to-be-a-better-developer/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2015/12/28/koa-source-lib-application/" class="post-link">koa框架源码阅读笔记 之 lib/application.js</a></h3>
    <p class="post-meta">@loveky · Dec 28, 2015</p>
  </header>
  
  <p class="post-summary">最近在学习ES6 Generator特性时发现了koa这个基于Generator的Web框架，它可以让开发者以一种“同步的方式”编写包含各种异步请求的Web应用。下面是关于它的一段中文介绍：
 由 Express 原班人马打造的 koa，致力于成为一个更小、更健壮、更富有表现力的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升常用错误处理效率。Koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。
 从介绍中可以看出这又是一个小而美的框架。到GitHub项目页面上看了一下发现源码里只有4个JS文件，总代码量只有1571行(以2015年12月26日最新稳定版1.1.2为准)。于是决定把代码clone下来学习一下，本篇会先从整个框架的入口文件lib/application.js说起。
总体说明 lib/application.js文件export出的是一个构造函数，用来创建一个koa应用。一个koa应用最常用的方法有2个： - listen(port) 执行listen后会通过http.createServer启动一个服务器并监听指定端口 - use(middleware) 注册一个中间件，一个koa应用可以注册多个中间件， 处理请求时会按照中间件注册的顺序执行这些中间件。
更多详细信息可以参考GitHub文档页面。
代码注释 function Application() { if (!(this instanceof Application)) return new Application; this.env = process.env.NODE_ENV || &#39;development&#39;; this.subdomainOffset = 2; this.middleware = []; this.proxy = false; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); }  以上就是Application构造函数的定义，很简洁，主要做了以下几件事情：
- 通过instanceof判断来支持不带new关键字的调用。 - 设置应用运行环境，会从环境变量NODE_ENV读取，默认值为development - 声明this.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2015/12/28/koa-source-lib-application/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2015/12/19/use-es6-in-jdf-projects/" class="post-link">在JDF项目中使用ES6新特性</a></h3>
    <p class="post-meta">@loveky · Dec 19, 2015</p>
  </header>
  
  <p class="post-summary">Note: 目前虽然JDF已经支持使用ES6开发脚本，但线上使用还在前期摸索阶段，请大家根据自己项目实际情况评估使用情况
最近利用业余时间给JDF增加了ES6代码的支持。背后的原理是在项目构建阶段利用Babel将.babel文件转译成ES5代码。关于Babel的更多使用方法可以参考其官网的配置文档。
下面开始正式介绍在利用ES6特性开发前的准备工作: - 升级JDF到最新版本（&gt;= 1.8.2） - 进入JDF项目目录，安装基本的Babel preset和plugin。关于preset和plugin的更多说明请参考文档
npm install babel-preset-es2015 npm install babel-plugin-transform-es3-member-expression-literals npm install babel-plugin-transform-es3-property-literals  配置项目的.gitignore文件，忽略node_modules目录。在文件中添加以下内容：  **/node_modules/   引入es6-base.js(包含 es5-shim和babel-polyfill)  至此，所有的准备工作就完成了。接下来就可以利用ES6的各种新特性开发了。需要注意的是所有包含了ES6特性的脚本文件扩展名必须是.babel，否则JDF是不会对其进行编译的。
最后是一份简单的FAQ：
Q: ES6都有哪些新特性，有没有推荐的学习资料？ 当然有，中文版的有阮一峰出品的ECMAScript 6入门。 英文的有： - ES6 In Depth来自Mozilla团队博客的一系列文章，每篇讲解一个新特性。建议按时间顺序阅读。 - Understanding ECMAScript 6来自Nicholas C. Zakas大神的一本ES6小书。
Q: 我想使用额外的Babel plugin或preset该怎样配置？ 只需在package.json中指定需要额外引入的plugin或preset，例如：
&#34;babel&#34;: { &#34;plugins&#34;: [&#34;syntax-async-functions&#34;,&#34;transform-regenerator&#34;], &#34;presets&#34;: [&#34;stage-0&#34;] } 并在JDF项目的目录中安装相关npm package即可。
Q: .babel文件编译出来的代码我看不懂，出了问题如何调试呢？ 我们看到的经过Babel转译后的JS是这样的： 这里包含了大量的Babel生成的代码，非常不利于调试。不过不用担心，JDF在本地开发模式中启用了sourceMap，你只需在Chrome开发者工具中的Sources Tab中在你要调试的JS文件目录下找到同名的.babel文件即可。相关JS中的报错信息，都会被映射到转译前的.babel文件的对应位置。
关于sourceMap的更多信息请参考这里。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2015/12/19/use-es6-in-jdf-projects/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2015/12/03/trimpath-syntax/" class="post-link">[译] TrimPath模板引擎语法</a></h3>
    <p class="post-meta">@loveky · Dec 3, 2015</p>
  </header>
  
  <p class="post-summary">本文翻译自JavaScript Template Syntax
表达式与表达式修饰符  ${expr} ${expr|modifier} ${expr|modifier1|modifier2|...|modifierN} ${expr|modifier1:argExpr1_1} ${expr|modifier1:argExpr1_1,argExpr1_2,...,argExpr1_N} ${expr|modifier1:argExpr1_1,argExpr1_2|...|modifierN:argExprN_1,argExprN_2,...,argExprN_M}   expr可以是不包含右花括号}的任何合法JavaScript表达式 修饰符的格式是modifierName[:argExpr1[,argExpr2[,argExprN]]]  argExpr可以是任何合法的expr    Examples: ${customer.firstName} ${customer.firstName|capitalize} ${customer.firstName|default:&#34;no name&#34;|capitalize} ${article.getCreationDate()|default:new Date()|toCalenderControl:&#34;YYYY.MM.DD&#34;,true,&#34;Creation Date&#34;} ${(lastQuarter.calcRevenue() - fixedCosts) / 1000000}  这里有一份内置的修饰符列表，你也可以通过TrimPath提供的API来创建自定义的修饰符。
表达式还可以写成${% customer.firstName %}这种形式，多出的%字符允许你的表达式中出现花括号}。例如：
 Visit our ${% emitLink(&#39;Solutions and Products&#39;, { color: &#39;red&#39;, blink: false }) %}  表达式中的空白字符是可选的，你也可以写成下面的格式：
 ${%customer.firstName%} ${%customer.firstName|capitalize%}  声明 声明标签可以嵌套使用。
控制流  {if testExpr} {elseif testExpr} {else} {/if}   testExpr可以是任何不包含}的JavaScript表达式 testExpr不需要被(和)包围  示例：</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2015/12/03/trimpath-syntax/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2014/05/04/di-in-angularjs/" class="post-link">AngularJS中的依赖注入</a></h3>
    <p class="post-meta">@loveky · May 4, 2014</p>
  </header>
  
  <p class="post-summary">本文译自https://docs.angularjs.org/guide/di
依赖注入 依赖注入(DI)是一种解决组件如何获取其依赖这一问题的设计模式。
Angular injector子系统负责创建组件，解决它们的依赖，并按要求将它们提供给其他组件。
如果想深入了解DI，可以查看依赖注入的Wikipedia以及Martin Fowler的这篇Inversion of Control。
DI in a Nutshell 一个组件要想获取它的依赖可以通过以下三种途径：
 直接创建这个依赖的一个实例，通常使用new操作符
 通过全局变量查找已经被创建的依赖
 依赖可以作为参数传递给需要它的组件
  前两种获取依赖的方式并不理想，因为这会导致依赖关系被硬编码进代码中。这会导致更新依赖关系变得很复杂。在测试时尤其如此，我们通常会提供mock过的依赖关系以隔离不同组件间的测试，硬编码会导致每次测试都需要修改相关的源码。
相比之下，第三种方式是最可行的，因为它将解决依赖关系的责任从组件中移除。依赖只是简单的作为参数传递给组件：
function SomeClass(greeter) { this.greeter = greeter; } SomeClass.prototype.doSomething = function(name) { this.greeter.greet(name); }  在上边的例子中，SomeClass并不关心如何创建或找到greeter，它只是在初始化时从参数列表里取出需要的依赖即可。
但这样做的问题是，寻找/创建依赖的责任被转交给了调用SomeClass的代码。
为了统一管理依赖关系，每个Angular应用都有一个injector。injector是一个服务定位器，它负责查找或创建依赖。
下面是一个使用injector服务的例子：
// Provide the wiring information in a module var myModule = angular.module(&#39;myModule&#39;, []);  下面的代码告诉injector如何创建greeter服务。需要注意的是greeter又依赖于$window服务。greeter实际上是一个包含greet方法的对象。
myModule.factory(&#39;greeter&#39;, function($window) { return { greet: function(text) { $window.alert(text); } }; });  下面的代码演示了如何创建一个injector并通过它来请求greeter服务:</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2014/05/04/di-in-angularjs/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2014/04/11/angularjs-ng-model/" class="post-link">AngularJS源码阅读之ngModel</a></h3>
    <p class="post-meta">@loveky · Apr 11, 2014</p>
  </header>
  
  <p class="post-summary">数据的双向绑定可能是Angular最为人们熟知的特性之一。举个最简单的例子 
可以在result页面中看到，每当在input中输入时，$scope中对应model的值也改变了。反之，当用户点击Set按钮在$scope中更新了model的值时，input输入框中的内容也对应更新了。
所有的这些魔法只需要我们在input元素上指定一个ng-model属性。可见ng-model这个directive是双向绑定这一特性不可缺少一点。本文就继续从源代码入手看看ngModel的实现方式以及其它directive是如何与ngModel交互的。
ngModel被定义在input.js。从名字上可看出，该文件还定义input这个directive，从这点也可以看出ngModel与input之间的紧密关系。
注: 文中所有涉及到的AngularJS源码均来自angular-1.2.8版本。
var ngModelDirective = function() { return { require: [&#39;ngModel&#39;, &#39;^?form&#39;], controller: NgModelController, link: function(scope, element, attr, ctrls) { // notify others, especially parent forms  var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl; formCtrl.$addControl(modelCtrl); scope.$on(&#39;$destroy&#39;, function() { formCtrl.$removeControl(modelCtrl); }); } }; };  可以看出ngModel依赖于ngModelController以及可选的formController。ngModel在link方法中只做了2件事:
 如果声明了ngModel的元素出现在一个form中，那么就向上层form注册自身 注册了$destroy事件的监听器，该事件触发时告知上层form移除对自身的引用  link方法如此简单以至于我们还没看到关于数据绑定的任何信息。看来问题的答案都藏在ngModelController中了。接下来看看ngModelController中都发生了什么。
var NgModelController = [&#39;$scope&#39;, &#39;$exceptionHandler&#39;, &#39;$attrs&#39;, &#39;$element&#39;, &#39;$parse&#39;, function($scope, $exceptionHandler, $attr, $element, $parse) { this.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2014/04/11/angularjs-ng-model/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2014/04/11/angularjs-controller/" class="post-link">Angular中的Controller</a></h3>
    <p class="post-meta">@loveky · Apr 11, 2014</p>
  </header>
  
  <p class="post-summary">在Angular中，一个Controller是一个JavaScript构造函数。当一个Controller通过ng-controller附加到某个DOM元素上时，Angular会使用相应Controller的构造函数来初始化一个新的Controller对象。一个新的child scope会被创建并作为可注入的参数(就是我们看到的$scope)传递给该Controller的构造函数。
使用Controller：
 为$scope对象设置初始状态
 为$scope对象添加行为
  不要使用Controller:
 修改DOM —— Controllers应该只负责业务逻辑。将任何UI的逻辑放进Controller都会极大地破坏其可测试性。Angular中可以使用数据绑定用来更新页面中的数据或使用directive来封装DOM操作。 格式化input数据 —— 使用angular form controls 过滤输出数据 —— 使用Angular中的filter机制 跨Controller之间的代码或状态共享 —— 使用Angular中的service机制 管理其他组件的生命周期  </p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2014/04/11/angularjs-controller/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2014/04/02/angularjs-ngrepeat/" class="post-link">AngularJS源码阅读之ngRepeat</a></h3>
    <p class="post-meta">@loveky · Apr 2, 2014</p>
  </header>
  
  <p class="post-summary">注: 文中所有涉及到的AngularJS源码均来自angular-1.2.8版本。
注2: 本文结构为一段代码配一段说明，代码在上，说明在下。
从3月3号到现在，进入新公司也有1个月了。过去这一个月里主要负责公司内部某个DevOps工具开发过程中的前端部分。由于涉及到较多的网页交互，该项目的前端部分使用了AngularJS这个框架。本人这正好借助这个机会进一步了解了AngularJS的相关知识。
这两天项目主体完成，准备上线，算是有了一些自由时间，正好借此机会学习一下AngularJS内部的实现机制。
本篇来说说最常见的directive之一 ngRepeat
该文件的整体结构如下：
var ngRepeatDirective = [&#39;$parse&#39;, &#39;$animate&#39;, function($parse, $animate) { var NG_REMOVED = &#39;$$NG_REMOVED&#39;; var ngRepeatMinErr = minErr(&#39;ngRepeat&#39;); return { transclude: &#39;element&#39;, priority: 1000, terminal: true, $$tlb: true, link: function($scope, $element, $attr, ctrl, $transclude){ ..... } }; function getBlockStart(block) { return block.clone[0]; } function getBlockEnd(block) { return block.clone[block.clone.length - 1]; } }];  ngRepeatDirective是一个数组，它会被传递给directive方法用来生成ngRepeat这个directive。可以看到ngRepeat依赖于$parse和$animate两个服务。$parse用来将字符串解析成javascript函数。$animate用来给DOM改变附加上动画效果。文件最后声明了两个helper方法，会在稍后的分析中介绍到。
接下来把最大的篇幅交给这个directive的核心——link方法。
var expression = $attr.ngRepeat; var match = expression.match(/^\s*([\s\S]&#43;?)\s&#43;in\s&#43;([\s\S]&#43;?)(?:\s&#43;track\s&#43;by\s&#43;([\s\S]&#43;?))?\s*$/), trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, hashFnLocals = {$id: hashKey}; if (!</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2014/04/02/angularjs-ngrepeat/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2014/04/01/angularjs-directive-compile-link/" class="post-link">AngularJS Directive之compile与link</a></h3>
    <p class="post-meta">@loveky · Apr 1, 2014</p>
  </header>
  
  <p class="post-summary">刚开始学习 AngularJS Directive 时，总是不太能搞明白 compile 和 link 两个属性的含义和区别。最近写的多一些，读的资料也多了一些，渐渐有了一些理解，简单记录下来：
compile 属性是一个函数。该函数会针对每一个 directive 的实例执行一次，在 compile 阶段：
 不能访问 scope 元素还没有被插入 document 可以修改 template，最终结果会被 angular 缓存  link 属性可以有两种配置方式。 link 属性可以被设置为一个对象，包含 pre, post 两个属性，分别对应一个函数(preLink, postLink)。preList，postLink 的区别在于执行顺序。preLink 是自顶向下的，先父节点，后子节点，postLink 正好相反。
.directive{ return { link: { pre: function preLink(){ ... }, post: function postLink() { ... } } } }  link 属性也可以被直接设置为一个函数，则默认相当于设置了 postLink 函数。
.directive{ return { link: function link(){ ... } } }  等于</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2014/04/01/angularjs-directive-compile-link/">阅读全文 →</a>
  </footer>
</article>

      
    
    
      <footer class="list-footer">
        <nav class="pagination">
          <h3 class="offscreen">Pagination</h3>
          
            <a class="pagination-previous" href="https://loveky.github.io/post/page/3/">← Newer Posts</a>
          
          
            <a class="pagination-next" href="https://loveky.github.io/post/page/5/">Older Posts →</a>
          
        </nav>
      </footer>
    
  </section>
  
<footer class="site-footer">
  <p>© 2017-2019 loveky</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>








<script src="https://loveky.github.io/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>








  </body>
</html>
