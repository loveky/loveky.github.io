<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8" />

  
  <title>
  Posts
   | loveky的博客
</title>

  
  
  <link href="//cdn.jsdelivr.net" rel="dns-prefetch">
  <link href="//cdnjs.cloudflare.com" rel="dns-prefetch">
  <link href="//at.alicdn.com" rel="dns-prefetch">
  <link href="//fonts.googleapis.com" rel="dns-prefetch">
  <link href="//fonts.gstatic.com" rel="dns-prefetch">
  <link href="///disqus.com" rel="dns-prefetch">
  <link href="//c.disquscdn.com" rel="dns-prefetch">
  
  
  

  

  
  <meta name="author" content="loveky">
  

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@loveky_">
  <meta name="twitter:title" content="loveky的博客">
  
  <meta name="twitter:image" content="/images/avatar.jpg">

  
  <meta property="og:type" content="website">
  <meta property="og:title" content="loveky的博客">
  
  <meta property="og:url" content="https://loveky.github.io/post/">
  <meta property="og:image" content="/images/avatar.jpg">




<meta name="generator" content="Hugo 0.54.0">


<link rel="canonical" href="https://loveky.github.io/post/">
<link rel="alternate" type="application/rss+xml" href="https://loveky.github.io/post/index.xml" title="loveky">

<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="format-detection" content="telephone=no,email=no,adress=no">
<meta http-equiv="Cache-Control" content="no-transform">


<meta name="robots" content="index,follow">
<meta name="referrer" content="origin-when-cross-origin">







<meta name="theme-color" content="#02b875">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="apple-mobile-web-app-title" content="loveky">
<meta name="msapplication-tooltip" content="loveky">
<meta name='msapplication-navbutton-color' content="#02b875">
<meta name="msapplication-TileColor" content="#02b875">
<meta name="msapplication-TileImage" content="/icons/icon-144x144.png">
<link rel="icon" href="https://loveky.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://loveky.github.io/icons/icon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://loveky.github.io/icons/icon-32x32.png">
<link rel="icon" sizes="192x192" href="https://loveky.github.io/icons/icon-192x192.png">
<link rel="apple-touch-icon" href="https://loveky.github.io/icons/icon-152x152.png">
<link rel="manifest" href="https://loveky.github.io/manifest.json">


<link rel="preload" href="https://loveky.github.io/styles/main.min.css" as="style">
<link rel="preload" href="https://fonts.googleapis.com/css?family=Lobster" as="style">
<link rel="preload" href="https://loveky.github.io/images/avatar.jpg" as="image">
<link rel="preload" href="https://loveky.github.io/images/grey-prism.svg" as="image">


<style>
  body {
    background: rgb(244, 243, 241) url('/images/grey-prism.svg') repeat fixed;
  }
</style>
<link rel="stylesheet" href="https://loveky.github.io/styles/main.min.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-114966753-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-114966753-1');
</script>







  
  
<!--[if lte IE 8]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/videojs-ie8@1.1.2/dist/videojs-ie8.min.js"></script>
<![endif]-->

<!--[if lte IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/eligrey-classlist-js-polyfill@1.2.20180112/classList.min.js"></script>
<![endif]-->


</head>
  <body>
    
    <div class="suspension">
      <a role="button" aria-label="Go to top" title="Go to top" class="to-top is-hide"><span class="icon icon-up" aria-hidden="true"></span></a>
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="https://loveky.github.io/images/avatar.jpg" alt="Avatar">
  
  <h2 class="title">loveky</h2>
  
  <p class="subtitle">记录生活点滴</p>
  <button class="menu-toggle" type="button" aria-label="Main Menu" aria-expanded="false" tab-index="0">
    <span class="icon icon-menu" aria-hidden="true"></span>
  </button>

  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
          
          
           is-active">
          <a href="https://loveky.github.io/">首页</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/tags/">标签</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/archive/">归档</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/links/">链接</a>
        </li>
      
        <li class="menu-item
          
          
          ">
          <a href="https://loveky.github.io/about/">关于我</a>
        </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list"><li class="social-item">
          <a href="mailto:eWx6Y3lseEBnbWFpbC5jb20=" title="Email" aria-label="Email">
            <span class="icon icon-email" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//github.com/loveky" title="GitHub" aria-label="GitHub">
            <span class="icon icon-github" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//twitter.com/loveky_" title="Twitter" aria-label="Twitter">
            <span class="icon icon-twitter" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//stackoverflow.com/users/1513552" title="stackOverflow"  aria-label="stackOverflow">
            <span class="icon icon-stackoverflow" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//www.zhihu.com/people/loveky" title="Zhihu" aria-label="Zhihu">
            <span class="icon icon-zhihu" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a href="//www.douban.com/people/54047566" title="Douban" aria-label="Douban">
            <span class="icon icon-douban" aria-hidden="true"></span>
          </a>
        </li><li class="social-item">
          <a rel="alternate" type="application/rss+xml" href="https://loveky.github.io/index.xml" title="RSS" aria-label="RSS">
            <span class="icon icon-rss" aria-hidden="true"></span>
          </a>
        </li></ul>
  </nav>
</header>

  <section class="main post-list">
    <header class="list-header offscreen">
      <h2 class="list-label">Posts List</h2>
    </header>
    
    
      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/05/02/meet-deno/" class="post-link">初识 Deno</a></h3>
    <p class="post-meta">@loveky · May 2, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img30.360buyimg.com/uba/jfs/t1/33681/25/10580/438939/5ccedcd9Eefb0efcf/60eb84fc6c066d49.gif" alt="初识 Deno" lazyload="on">
  
  <p class="post-summary">几天前的 JavaScript Weekly 里推送了一条名为 “A Look at Deno: A New JavaScript Runtime” 的视频，视频的内容是 Deno 的作者(同时也是 Node.js 项目的最初发起人与维护者) Ryan Dahl 在今年 4 月初的 JS Fest 大会上做的关于 Deno 的演讲。
 Deno, a new way to JavaScript  看完视频感觉这个项目挺有趣，于是花了一点时间做了一些了解，记录如下。
</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/05/02/meet-deno/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/02/14/typescript-generic/" class="post-link">TypeScript 中的泛型(Generic)</a></h3>
    <p class="post-meta">@loveky · Feb 14, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img12.360buyimg.com/uba/s300x300_jfs/t1/30646/20/1952/28135/5c63d9dbEc21e77b4/0f96a5ed30759c29.png" alt="TypeScript 中的泛型(Generic)" lazyload="on">
  
  <p class="post-summary">在函数中使用泛型 这里 T 可以代表任意类型。
function identity&lt;T&gt;(arg: T): T { return arg; } 使用时可以明确指定类型：
let output = identity&lt;string&gt;(&#34;myString&#34;);  不过更多时候是交给 TypeScript 进行类型推断：
let output = identity(&#34;myString&#34;);  在接口中使用泛型 interface GenericIdentityFn { &lt;T&gt;(arg: T): T; } function identity&lt;T&gt;(arg: T): T { return arg; } let myIdentity: GenericIdentityFn = identity; 我们还可以把泛型参数提升到整个接口的层面，像下面这样：
interface GenericIdentityFn&lt;T&gt; { (arg: T): T; } 然后在我们使用这个接口的时候，必须明确指定这个泛型参数的类型：
function identity&lt;T&gt;(arg: T): T { return arg; } let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 我们得到的 myIdentity 方法只能接受数字作为参数。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/02/14/typescript-generic/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/02/13/typescript-function-types-and-indexed-types/" class="post-link">TypeScript 中的函数类型与索引类型</a></h3>
    <p class="post-meta">@loveky · Feb 13, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img12.360buyimg.com/uba/s300x300_jfs/t1/30646/20/1952/28135/5c63d9dbEc21e77b4/0f96a5ed30759c29.png" alt="TypeScript 中的函数类型与索引类型" lazyload="on">
  
  <p class="post-summary">函数类型 利用 interface 声明函数类型，只需要把接口定义中的属性写成函数签名即可。
像这样：
interface SearchFunc { (source: string, subString: string): boolean; } 如果我们的函数本身还有一些属性，例如 Node.js 中的 require() 方法，我们既可以 require(&#34;package&#34;) 又可以 require.resolve(&#34;package&#34;)。这是需要首先为该方法定义一个接口，然后再通过 extends 它来添加属性。
interface NodeRequireFunction { (id: string): any; } interface NodeRequire extends NodeRequireFunction { resolve: RequireResolve; cache: any; extensions: NodeExtensions; main: NodeModule | undefined; } 索引类型 有时我们想让我们对象支持向数组那样按照数字下标来存取数据，有时我们会想创建一个”字典”对象来存取任意的 “key/value” 对应关系。这两种情况就需要声明索引类型。区别在于索引本身的类型是数字还是字符串。
interface StringArray { [index: number]: string; } interface NameAddressMap { [index: string]: string; } 我们可以把一个对象声明成既支持字符串索引有支持数字索引：
interface ItsOK { [index: string]: string; [index: number]: string; } 如果我们的对象要同时支持两种索引类型，那么必须保证字符串索引对应值的类型是数字索引对应值的类型的超集。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/02/13/typescript-function-types-and-indexed-types/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/02/12/nodejs-module-system/" class="post-link">Node.js 的模块系统</a></h3>
    <p class="post-meta">@loveky · Feb 12, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img20.360buyimg.com/uba/s300x300_jfs/t1/28747/1/6830/6538/5c6276c0E58a5b593/13cf35af9b707192.png" alt="Node.js 的模块系统" lazyload="on">
  
  <p class="post-summary">两个核心模块 require 和 module。
require 模块对应全局的 require 方法。module 模块对应每一个模块全局空间中的 module 属性。
Node.js 加载一个模块主要经历以下几个步骤：
 Resolving -&gt; Loading -&gt; Wrapping -&gt; Evaluating -&gt; Caching
 Resolving Node.js 中的模块和文件系统中的文件是一一对应的（这一点很重要）。加载模块的过程其实就是执行文件系统中的脚本并将结果载入内存的过程。
每一个模块都有一个 id 属性，该属性的值就是这个模块对应文件的绝对路径（在 REPL 里为 ““）。
Resolving 阶段的工作就是把我们 require 的字符串解析成一个文件系统中的绝对路径。根据我们 require 包的类型，这里又分为三种情况：
 核心模块。也即 Node.js 内置的模块，例如 “fs”、”path”、”http” 等，这类模块无需安装即可直接使用。 相对路径/绝对路径。Node.js 直接将相对路径转换成对应的绝对路径。 第三方依赖。如果不是前两种情况，那么 Node.js 会依次查找 module.paths 列表中的目录是否存在。 我们来看看 module.paths 中都有哪些目录： 可以看到主要是从当前目录逐级向上查找 node_modules 目录。这也就是为什么我们的依赖会被安装在 node_modules 目录下的原因。 为了向前兼容，Node.js 还会检查一些已经被废弃的目录，不推荐使用它们。
在找到这个列表中某个存在的目录之后，Node.js 会在该目录下继续查找，假设我们执行的是 require(&#34;moduleA&#34;)，那么又可以分为以下三种情况：
 存在一个 moduleA.js 文件，那么该文件就是最终我们要加载的文件。 存在一个 moduleA 子目录，且该目录下存在一个名为 index.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/02/12/nodejs-module-system/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2019/02/11/yarn-pnp/" class="post-link">Yarn 的 Plug&#39;n&#39;Play 特性</a></h3>
    <p class="post-meta">@loveky · Feb 11, 2019</p>
  </header>
  
    <img class="post-cover" src="https://img20.360buyimg.com/uba/s300x300_jfs/t1/8346/34/14379/15918/5c616cecE985b19c2/350ab0c1cb269d3a.jpg" alt="Yarn 的 Plug&#39;n&#39;Play 特性" lazyload="on">
  
  <p class="post-summary">前言 Yarn 团队在春节前公布了 Yarn 2.0 的规划。其中提到了一个之前没听说过的名词 “PnP”。发现 Yarn 的这个功能早在 18 年 9 月份就被提出并实现了。于是花了一些时间了解了一下它的工作原理以及解决的问题并整理除了本篇文章。
现状与痛点 Yarn 团队开发 PnP 特性最直接的原因就是现有的依赖管理方式效率太低。引用依赖时慢，安装依赖时也慢。
先说说 Node 在处理依赖引用时的逻辑，这个流程会有如下两种情况：
 如果我们传给 require() 调用的参数是一个核心模块（例如 “fs”、”path”等）或者是一个本地相对路径（例如 ./module-a.js 或 /my-li/module-b.js），那么 Node 会直接使用对应的文件。 如果不是前面描述的情况，那么 Node 会开始寻找一个名为 node_modules 的目录：  首先 Node 会在当前目录寻找 node_modules，如果没有则到父目录查找，以此类推直到系统根目录。 找到 node_modules 目录之后，再在该目录中寻找名为 moduleName.js 的文件或是名为 moduleName 的子目录。   此处旨在说明问题，对 Node 内部模块解析逻辑做了简化描述
可见 Node 在解析依赖时需要进行大量的文件 I/O 操作，效率并不高。
再来看看安装依赖时发生了什么，现阶段 yarn install 操作会执行以下 4 个步骤：
 将依赖包的版本区间解析为某个具体的版本号 下载对应版本依赖的 tar 包到本地离线镜像 将依赖从离线镜像解压到本地缓存 将依赖从缓存拷贝到当前目录的 node_modules 目录  其中第 4 步同样涉及大量的文件 I/O，导致安装依赖时效率不高（尤其是在 CI 环境，每次都需要安装全部依赖）。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2019/02/11/yarn-pnp/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2018/07/18/how-flutter-inheritedwidget-works/" class="post-link">从 Flutter 源码看 InheritedWidget 内部实现原理</a></h3>
    <p class="post-meta">@loveky · Jul 18, 2018</p>
  </header>
  
    <img class="post-cover" src="https://img11.360buyimg.com/uba/s300x300_jfs/t23086/34/1085755315/92891/9249e03d/5b4f1c76N2108c1ca.jpg" alt="从 Flutter 源码看 InheritedWidget 内部实现原理" lazyload="on">
  
  <p class="post-summary">这两天学习了一下 Flutter 中的 InheritedWidget 的使用方法，顺便查看一下相关源码了解了其底层实现机制。特地记录一下。
Prerequirements 由于本文主要是从源码的角度分析 InheritedWidget 的工作原理，所以对阅读本文的小伙伴的 Flutter 知识有一定的要求。主要有以下几点，如果其中某部分你还不太清楚，请先阅读相关链接：
 了解 Flutter 的基本用法。 了解 Flutter 中的 Widget 和 Element 的基本概念。 推荐阅读：Flutter, what are Widgets, RenderObjects and Elements? 对 Flutter 中 Element 的生命周期有基本了解。推荐阅读：Element class  下面开始正文。
InheritedWidget 的使用方法 先看一个 InheritedWidget 最简单的使用示例：
import &#39;package:flutter/material.dart&#39;; void main() =&gt; runApp(new MyApp()); class MyWelcomeInfo extends InheritedWidget { MyWelcomeInfo({Key key, this.welcomeInfo, Widget child}) : super(key: key, child: child); final String welcomeInfo; @override bool updateShouldNotify(InheritedWidget oldWidget) { return oldWidget.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2018/07/18/how-flutter-inheritedwidget-works/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2018/07/13/flutter-listview-child-visibility-monitor/" class="post-link">Flutter 中 ListView 组件的子元素曝光统计</a></h3>
    <p class="post-meta">@loveky · Jul 13, 2018</p>
  </header>
  
    <img class="post-cover" src="https://img11.360buyimg.com/uba/s300x300_jfs/t20749/152/2116621965/135404/e6908175/5b47fd61Ne37248ec.jpg" alt="Flutter 中 ListView 组件的子元素曝光统计" lazyload="on">
  
  <p class="post-summary">在使用 Flutter 开发应用的过程中我们经常遇到需要展示一组连续元素的情景。这时我们通常会选择使用 ListView 组件。在电商场景中，被展示的元素通常是一组商品、一组店铺又或是一组优惠券信息。把这些信息正确的展示出来仅仅是第一步，通常业务同学为了统计用户的浏览习惯、活动的展示效果还会让我们上报列表元素的曝光信息。
什么是曝光信息？ 什么是曝光是信息呢？简单来说就是用户实际看到了一个列表中的哪些元素？实际展示给用户的这部分元素用户浏览了多少次？
让我们通过一个简单示例应用来说明：
import &#39;package:flutter/material.dart&#39;; class Card extends StatelessWidget { final String text; Card({ @required this.text, }); @override Widget build(BuildContext context) { return Container( margin: EdgeInsets.only(bottom: 10.0), color: Colors.greenAccent, height: 300.0, child: Center( child: Text( text, style: TextStyle(fontSize: 40.0), ), ), ); } } class HelloFlutter extends StatelessWidget { final items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]; @override Widget build(BuildContext context) { return ListView.</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2018/07/13/flutter-listview-child-visibility-monitor/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2018/07/05/config-lantern-as-shell-proxy/" class="post-link">利用蓝灯为命令行配置HTTP代理</a></h3>
    <p class="post-meta">@loveky · Jul 5, 2018</p>
  </header>
  
    <img class="post-cover" src="https://img11.360buyimg.com/uba/jfs/t22204/310/1882466733/2312/45f34ee8/5b3d8ad9N988340c6.png" alt="利用蓝灯为命令行配置HTTP代理" lazyload="on">
  
  <p class="post-summary">蓝灯是个好工具。可以帮忙我们访问一些由于众所周知的原因在国内无法正常访问的网站(比如 Google、Stack Overflow、Medium 等等)。
每次启动蓝灯，它会自动修改操作系统的网络代理指向它自己。不需要我们手动配置，很是方便。
需要网络代理的地方其实不止是浏览器，很多命令行工具也会访问网络。比如，我们通过 homebrew 安装 dart 的时候，brew 命令会从 Google 的服务器上下载安装文件。然后你就会看到网络连接错误的提示信息。
要解决这类问题，只需要为 Shell 设置两个环境变量 HTTP_PROXY 和 HTTPS_PROXY 即可。我们直接利用蓝灯在本地启动好的代理端口。
我们首先找到蓝灯在本地启动的具体端口号。打开蓝灯，依次选择 Settings -&gt; ADVANCED SETTINGS 即可看到蓝灯在本地选择的端口号。
然后去 Shell 里执行以下两个命令设置环境变量：
export HTTP_PROXY=http://127.0.0.1:51350 export HTTPS_PROXY=http://127.0.0.1:51350 就完成配置了。
最后为了避免每次都要敲这么长的命令，我们写一个 Shell 函数：
# http proxy util hp() { if [ &#34;$1&#34; = &#34;enable&#34; ] then PORT=&#34;51350&#34; if [ -n &#34;$2&#34; ] then PORT=&#34;$2&#34; fi export HTTP_PROXY=http://127.0.0.1:$PORT export HTTPS_PROXY=http://127.0.0.1:$PORT else export HTTP_PROXY=&#34;&#34; export HTTPS_PROXY=&#34;&#34; fi } 把这都函数代码放到 Shell 启动脚本里。然后需要开启代理的时候执行 hp enable 即可，或是指定代理端口号 hp enable 33333。关闭代理执行 hp 即可。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2018/07/05/config-lantern-as-shell-proxy/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2018/07/04/flutter-first-experience/" class="post-link">Flutter 初体验</a></h3>
    <p class="post-meta">@loveky · Jul 4, 2018</p>
  </header>
  
    <img class="post-cover" src="https://img12.360buyimg.com/uba/s300x300_jfs/t22333/316/1892258469/68208/66d017fd/5b3ce1e8N69717104.png" alt="Flutter 初体验" lazyload="on">
  
  <p class="post-summary">初识 Flutter 还是在上个月的 GMTC 大会上。来自 Google 的工程师现场演示了如何使用 Flutter 构建美观、高性能的移动应用。个人对其中一些特性，比如良好的开发者体验、优秀的跨平台能力很感兴趣。于是决定在会后亲自体验一下。
最近几天尝试使用 Flutter 把京东 APP 中的排行榜频道的首屏布局实现了一下，算是对基于 Flutter 的开发有了一个最简单的了解，特地记录一下，方便其他想了解、尝试 Flutter 框架的小伙伴。
首先看看我实现了一个什么样的界面：
接下来让我们从不同方面说说 Flutter 的开发。
Flutter 开发环境搭建 安装 Flutter 不同平台的安装流程基本一致，这里就以 macOS 为例。首先下载 flutter macOS 版，并解压。
把 Flutter 的 bin 目录添加到系统 PATH 中：
export PATH=~/Software/flutter/bin:$PATH 提示：记得把这行代码放到你的 shell 启动脚本中，避免每次都要手动执行。
路径添加完成后就可以执行 flutter 命令啦。 Flutter 提供了一个 flutter doctor 命令协助我们安装 Flutter 的依赖。它会检查本地是否有 iOS 和 Android 的开发环境。如果检测到依赖缺失，它还会给出对应依赖的安装方法。你只需要不断执行该方法，然后安装缺失的依赖，直到全部依赖安装完成即可。
配置代码编辑器 主要是给 IDE 安装相关插件。
VS Code 上只需要安装 flutter 扩展即可。 Android Studio 上需要安装 flutter 和 dart 两个插件。</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2018/07/04/flutter-first-experience/">阅读全文 →</a>
  </footer>
</article>

      
        <article class="post-entry">
  <header class="post-header">
    <h3 class="post-title"><a href="https://loveky.github.io/2018/06/05/unit-testing-react-component-with-jest/" class="post-link">利用 Jest 为 React 组件编写单元测试</a></h3>
    <p class="post-meta">@loveky · Jun 5, 2018</p>
  </header>
  
    <img class="post-cover" src="https://img20.360buyimg.com/uba/s300x300_jfs/t20215/257/718598224/50702/4b2501db/5b168cc4N1fc2ed0b.png" alt="利用 Jest 为 React 组件编写单元测试" lazyload="on">
  
  <p class="post-summary">图片来自 https://blog.algolia.com   在上一篇文章中我们介绍了什么是单元测试以及单元测试框架 Jest 的基本用法。在本文中我们会具体聊聊如何用 Jest 为 React 组件编写单元测试。
首先我们要明确的一点，那就是 React 组件的单元测试本质是也是单元测试。因此它也符合我们之前介绍过的单元测试的全部特点。唯一不同的地方在于 React 组件的单元测试中我们需要找到合适的方法对执行结果进行断言。换言之，我们要根据 React 的特点来设置代码是否正确执行的判断条件。
那么 React 组件和其它的被测试对象有何不同呢？仔细想过，我们会发现：
 React 组件的 render 结果是一个组件树，并且整个树最终会被解析成一个纯粹由 HTML 元素构成的树形结构 React 组件可以拥有 state，且 state 的变化会影响 render 结果 React 组件可以拥有生命周期函数，这些生命周期函数会在特定时间点执行  知道了要测试的内容，接下来的问题就是如何执行一个 React 组件并编写断言了。如何执行一个 React 组件呢？看到这个问题估计大多数儿人是蒙的。平时不就是直接 ReactDOM.render 吗？不错，ReactDOM.render 确实可以执行一个 React 组件并将它渲染到页面中，但这种方式不利于编写测试代码。
有没有更简单的方式呢？其实 React 已经帮我们提供好了工具，让我们一起来看看。
React 提供的测试工具 在 React 的官方文档中提到了两个用于测试 React 组件的库。让我们分别介绍。
react-test-renderer 在说 react-test-renderer 之前，让我们先聊聊什么是 renderer。React 最早是被用来开发网页的，所以早期的 React 库中还包含了大量和 DOM 相关的逻辑。后来 React 的设计思想慢慢被迁移到其它场景，最被人们熟知的莫过于 React Native 了。为了灵活性和扩展性，React 的代码被分拆为 React 核心代码与各种 renderer。React 自带了 3 个 renderer，前两个是大家常见的：</p>
  <footer class="post-footer">
    <a class="read-more" href="https://loveky.github.io/2018/06/05/unit-testing-react-component-with-jest/">阅读全文 →</a>
  </footer>
</article>

      
    
    
      <footer class="list-footer">
        <nav class="pagination">
          <h3 class="offscreen">Pagination</h3>
          
          
            <a class="pagination-next" href="https://loveky.github.io/post/page/2/">Older Posts →</a>
          
        </nav>
      </footer>
    
  </section>
  
<footer class="site-footer">
  <p>© 2017-2019 loveky</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank" rel="noopener">Nuo</a>.</p>
  
</footer>


<script src="https://cdn.jsdelivr.net/npm/smooth-scroll@15.0.0/dist/smooth-scroll.min.js"></script>








<script src="https://loveky.github.io/scripts/index.min.js"></script>

<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('\/service-worker.js').then(function() {
      console.log('[ServiceWorker] Registered');
    });
  }
</script>








  </body>
</html>
